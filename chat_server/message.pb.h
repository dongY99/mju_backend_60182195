// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
namespace mju {
class CSChat;
struct CSChatDefaultTypeInternal;
extern CSChatDefaultTypeInternal _CSChat_default_instance_;
class CSCreateRoom;
struct CSCreateRoomDefaultTypeInternal;
extern CSCreateRoomDefaultTypeInternal _CSCreateRoom_default_instance_;
class CSJoinRoom;
struct CSJoinRoomDefaultTypeInternal;
extern CSJoinRoomDefaultTypeInternal _CSJoinRoom_default_instance_;
class CSLeaveRoom;
struct CSLeaveRoomDefaultTypeInternal;
extern CSLeaveRoomDefaultTypeInternal _CSLeaveRoom_default_instance_;
class CSName;
struct CSNameDefaultTypeInternal;
extern CSNameDefaultTypeInternal _CSName_default_instance_;
class CSRooms;
struct CSRoomsDefaultTypeInternal;
extern CSRoomsDefaultTypeInternal _CSRooms_default_instance_;
class CSShutdown;
struct CSShutdownDefaultTypeInternal;
extern CSShutdownDefaultTypeInternal _CSShutdown_default_instance_;
class SCChat;
struct SCChatDefaultTypeInternal;
extern SCChatDefaultTypeInternal _SCChat_default_instance_;
class SCCreateRoomResult;
struct SCCreateRoomResultDefaultTypeInternal;
extern SCCreateRoomResultDefaultTypeInternal _SCCreateRoomResult_default_instance_;
class SCJoinRoomResult;
struct SCJoinRoomResultDefaultTypeInternal;
extern SCJoinRoomResultDefaultTypeInternal _SCJoinRoomResult_default_instance_;
class SCLeaveRoomResult;
struct SCLeaveRoomResultDefaultTypeInternal;
extern SCLeaveRoomResultDefaultTypeInternal _SCLeaveRoomResult_default_instance_;
class SCNameResult;
struct SCNameResultDefaultTypeInternal;
extern SCNameResultDefaultTypeInternal _SCNameResult_default_instance_;
class SCRoomsResult;
struct SCRoomsResultDefaultTypeInternal;
extern SCRoomsResultDefaultTypeInternal _SCRoomsResult_default_instance_;
class SCRoomsResult_RoomInfo;
struct SCRoomsResult_RoomInfoDefaultTypeInternal;
extern SCRoomsResult_RoomInfoDefaultTypeInternal _SCRoomsResult_RoomInfo_default_instance_;
class SCSystemMessage;
struct SCSystemMessageDefaultTypeInternal;
extern SCSystemMessageDefaultTypeInternal _SCSystemMessage_default_instance_;
class Type;
struct TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
}  // namespace mju
PROTOBUF_NAMESPACE_OPEN
template<> ::mju::CSChat* Arena::CreateMaybeMessage<::mju::CSChat>(Arena*);
template<> ::mju::CSCreateRoom* Arena::CreateMaybeMessage<::mju::CSCreateRoom>(Arena*);
template<> ::mju::CSJoinRoom* Arena::CreateMaybeMessage<::mju::CSJoinRoom>(Arena*);
template<> ::mju::CSLeaveRoom* Arena::CreateMaybeMessage<::mju::CSLeaveRoom>(Arena*);
template<> ::mju::CSName* Arena::CreateMaybeMessage<::mju::CSName>(Arena*);
template<> ::mju::CSRooms* Arena::CreateMaybeMessage<::mju::CSRooms>(Arena*);
template<> ::mju::CSShutdown* Arena::CreateMaybeMessage<::mju::CSShutdown>(Arena*);
template<> ::mju::SCChat* Arena::CreateMaybeMessage<::mju::SCChat>(Arena*);
template<> ::mju::SCCreateRoomResult* Arena::CreateMaybeMessage<::mju::SCCreateRoomResult>(Arena*);
template<> ::mju::SCJoinRoomResult* Arena::CreateMaybeMessage<::mju::SCJoinRoomResult>(Arena*);
template<> ::mju::SCLeaveRoomResult* Arena::CreateMaybeMessage<::mju::SCLeaveRoomResult>(Arena*);
template<> ::mju::SCNameResult* Arena::CreateMaybeMessage<::mju::SCNameResult>(Arena*);
template<> ::mju::SCRoomsResult* Arena::CreateMaybeMessage<::mju::SCRoomsResult>(Arena*);
template<> ::mju::SCRoomsResult_RoomInfo* Arena::CreateMaybeMessage<::mju::SCRoomsResult_RoomInfo>(Arena*);
template<> ::mju::SCSystemMessage* Arena::CreateMaybeMessage<::mju::SCSystemMessage>(Arena*);
template<> ::mju::Type* Arena::CreateMaybeMessage<::mju::Type>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mju {

enum Type_MessageType : int {
  Type_MessageType_CS_NAME = 0,
  Type_MessageType_CS_ROOMS = 1,
  Type_MessageType_CS_CREATE_ROOM = 2,
  Type_MessageType_CS_JOIN_ROOM = 3,
  Type_MessageType_CS_LEAVE_ROOM = 4,
  Type_MessageType_CS_CHAT = 5,
  Type_MessageType_CS_SHUTDOWN = 6,
  Type_MessageType_SC_ROOMS_RESULT = 7,
  Type_MessageType_SC_CHAT = 8,
  Type_MessageType_SC_SYSTEM_MESSAGE = 9
};
bool Type_MessageType_IsValid(int value);
constexpr Type_MessageType Type_MessageType_MessageType_MIN = Type_MessageType_CS_NAME;
constexpr Type_MessageType Type_MessageType_MessageType_MAX = Type_MessageType_SC_SYSTEM_MESSAGE;
constexpr int Type_MessageType_MessageType_ARRAYSIZE = Type_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_MessageType_descriptor();
template<typename T>
inline const std::string& Type_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_MessageType_descriptor(), enum_t_value);
}
inline bool Type_MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type_MessageType>(
    Type_MessageType_descriptor(), name, value);
}
// ===================================================================

class Type final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.Type) */ {
 public:
  inline Type() : Type(nullptr) {}
  ~Type() override;
  explicit PROTOBUF_CONSTEXPR Type(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type(const Type& from);
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type& operator=(Type&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }
  inline void Swap(Type* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Type& from) {
    Type::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.Type";
  }
  protected:
  explicit Type(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Type_MessageType MessageType;
  static constexpr MessageType CS_NAME =
    Type_MessageType_CS_NAME;
  static constexpr MessageType CS_ROOMS =
    Type_MessageType_CS_ROOMS;
  static constexpr MessageType CS_CREATE_ROOM =
    Type_MessageType_CS_CREATE_ROOM;
  static constexpr MessageType CS_JOIN_ROOM =
    Type_MessageType_CS_JOIN_ROOM;
  static constexpr MessageType CS_LEAVE_ROOM =
    Type_MessageType_CS_LEAVE_ROOM;
  static constexpr MessageType CS_CHAT =
    Type_MessageType_CS_CHAT;
  static constexpr MessageType CS_SHUTDOWN =
    Type_MessageType_CS_SHUTDOWN;
  static constexpr MessageType SC_ROOMS_RESULT =
    Type_MessageType_SC_ROOMS_RESULT;
  static constexpr MessageType SC_CHAT =
    Type_MessageType_SC_CHAT;
  static constexpr MessageType SC_SYSTEM_MESSAGE =
    Type_MessageType_SC_SYSTEM_MESSAGE;
  static inline bool MessageType_IsValid(int value) {
    return Type_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    Type_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    Type_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    Type_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return Type_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return Type_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MessageType* value) {
    return Type_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // required .mju.Type.MessageType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::mju::Type_MessageType type() const;
  void set_type(::mju::Type_MessageType value);
  private:
  ::mju::Type_MessageType _internal_type() const;
  void _internal_set_type(::mju::Type_MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:mju.Type)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.CSName) */ {
 public:
  inline CSName() : CSName(nullptr) {}
  ~CSName() override;
  explicit PROTOBUF_CONSTEXPR CSName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSName(const CSName& from);
  CSName(CSName&& from) noexcept
    : CSName() {
    *this = ::std::move(from);
  }

  inline CSName& operator=(const CSName& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSName& operator=(CSName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSName& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSName* internal_default_instance() {
    return reinterpret_cast<const CSName*>(
               &_CSName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CSName& a, CSName& b) {
    a.Swap(&b);
  }
  inline void Swap(CSName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CSName& from) {
    CSName::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSName";
  }
  protected:
  explicit CSName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:mju.CSName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSRooms final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mju.CSRooms) */ {
 public:
  inline CSRooms() : CSRooms(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CSRooms(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSRooms(const CSRooms& from);
  CSRooms(CSRooms&& from) noexcept
    : CSRooms() {
    *this = ::std::move(from);
  }

  inline CSRooms& operator=(const CSRooms& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSRooms& operator=(CSRooms&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSRooms& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSRooms* internal_default_instance() {
    return reinterpret_cast<const CSRooms*>(
               &_CSRooms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CSRooms& a, CSRooms& b) {
    a.Swap(&b);
  }
  inline void Swap(CSRooms* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSRooms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSRooms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSRooms>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSRooms& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSRooms& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSRooms";
  }
  protected:
  explicit CSRooms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mju.CSRooms)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSCreateRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.CSCreateRoom) */ {
 public:
  inline CSCreateRoom() : CSCreateRoom(nullptr) {}
  ~CSCreateRoom() override;
  explicit PROTOBUF_CONSTEXPR CSCreateRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSCreateRoom(const CSCreateRoom& from);
  CSCreateRoom(CSCreateRoom&& from) noexcept
    : CSCreateRoom() {
    *this = ::std::move(from);
  }

  inline CSCreateRoom& operator=(const CSCreateRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSCreateRoom& operator=(CSCreateRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSCreateRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSCreateRoom* internal_default_instance() {
    return reinterpret_cast<const CSCreateRoom*>(
               &_CSCreateRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CSCreateRoom& a, CSCreateRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(CSCreateRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSCreateRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSCreateRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSCreateRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSCreateRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CSCreateRoom& from) {
    CSCreateRoom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSCreateRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSCreateRoom";
  }
  protected:
  explicit CSCreateRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
  };
  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:mju.CSCreateRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSJoinRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.CSJoinRoom) */ {
 public:
  inline CSJoinRoom() : CSJoinRoom(nullptr) {}
  ~CSJoinRoom() override;
  explicit PROTOBUF_CONSTEXPR CSJoinRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSJoinRoom(const CSJoinRoom& from);
  CSJoinRoom(CSJoinRoom&& from) noexcept
    : CSJoinRoom() {
    *this = ::std::move(from);
  }

  inline CSJoinRoom& operator=(const CSJoinRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSJoinRoom& operator=(CSJoinRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSJoinRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSJoinRoom* internal_default_instance() {
    return reinterpret_cast<const CSJoinRoom*>(
               &_CSJoinRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CSJoinRoom& a, CSJoinRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(CSJoinRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSJoinRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSJoinRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSJoinRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSJoinRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CSJoinRoom& from) {
    CSJoinRoom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSJoinRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSJoinRoom";
  }
  protected:
  explicit CSJoinRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // required int32 roomId = 1;
  bool has_roomid() const;
  private:
  bool _internal_has_roomid() const;
  public:
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mju.CSJoinRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t roomid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSLeaveRoom final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mju.CSLeaveRoom) */ {
 public:
  inline CSLeaveRoom() : CSLeaveRoom(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CSLeaveRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSLeaveRoom(const CSLeaveRoom& from);
  CSLeaveRoom(CSLeaveRoom&& from) noexcept
    : CSLeaveRoom() {
    *this = ::std::move(from);
  }

  inline CSLeaveRoom& operator=(const CSLeaveRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSLeaveRoom& operator=(CSLeaveRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSLeaveRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSLeaveRoom* internal_default_instance() {
    return reinterpret_cast<const CSLeaveRoom*>(
               &_CSLeaveRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CSLeaveRoom& a, CSLeaveRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(CSLeaveRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSLeaveRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSLeaveRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSLeaveRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSLeaveRoom& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSLeaveRoom& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSLeaveRoom";
  }
  protected:
  explicit CSLeaveRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mju.CSLeaveRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.CSChat) */ {
 public:
  inline CSChat() : CSChat(nullptr) {}
  ~CSChat() override;
  explicit PROTOBUF_CONSTEXPR CSChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSChat(const CSChat& from);
  CSChat(CSChat&& from) noexcept
    : CSChat() {
    *this = ::std::move(from);
  }

  inline CSChat& operator=(const CSChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSChat& operator=(CSChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSChat* internal_default_instance() {
    return reinterpret_cast<const CSChat*>(
               &_CSChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CSChat& a, CSChat& b) {
    a.Swap(&b);
  }
  inline void Swap(CSChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CSChat& from) {
    CSChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSChat";
  }
  protected:
  explicit CSChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // required string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:mju.CSChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSShutdown final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mju.CSShutdown) */ {
 public:
  inline CSShutdown() : CSShutdown(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CSShutdown(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSShutdown(const CSShutdown& from);
  CSShutdown(CSShutdown&& from) noexcept
    : CSShutdown() {
    *this = ::std::move(from);
  }

  inline CSShutdown& operator=(const CSShutdown& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSShutdown& operator=(CSShutdown&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSShutdown& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSShutdown* internal_default_instance() {
    return reinterpret_cast<const CSShutdown*>(
               &_CSShutdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CSShutdown& a, CSShutdown& b) {
    a.Swap(&b);
  }
  inline void Swap(CSShutdown* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSShutdown* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSShutdown* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSShutdown>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSShutdown& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSShutdown& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSShutdown";
  }
  protected:
  explicit CSShutdown(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mju.CSShutdown)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCNameResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCNameResult) */ {
 public:
  inline SCNameResult() : SCNameResult(nullptr) {}
  ~SCNameResult() override;
  explicit PROTOBUF_CONSTEXPR SCNameResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCNameResult(const SCNameResult& from);
  SCNameResult(SCNameResult&& from) noexcept
    : SCNameResult() {
    *this = ::std::move(from);
  }

  inline SCNameResult& operator=(const SCNameResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCNameResult& operator=(SCNameResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCNameResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCNameResult* internal_default_instance() {
    return reinterpret_cast<const SCNameResult*>(
               &_SCNameResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SCNameResult& a, SCNameResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SCNameResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCNameResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCNameResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCNameResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCNameResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCNameResult& from) {
    SCNameResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCNameResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCNameResult";
  }
  protected:
  explicit SCNameResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:mju.SCNameResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCRoomsResult_RoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCRoomsResult.RoomInfo) */ {
 public:
  inline SCRoomsResult_RoomInfo() : SCRoomsResult_RoomInfo(nullptr) {}
  ~SCRoomsResult_RoomInfo() override;
  explicit PROTOBUF_CONSTEXPR SCRoomsResult_RoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCRoomsResult_RoomInfo(const SCRoomsResult_RoomInfo& from);
  SCRoomsResult_RoomInfo(SCRoomsResult_RoomInfo&& from) noexcept
    : SCRoomsResult_RoomInfo() {
    *this = ::std::move(from);
  }

  inline SCRoomsResult_RoomInfo& operator=(const SCRoomsResult_RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCRoomsResult_RoomInfo& operator=(SCRoomsResult_RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCRoomsResult_RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCRoomsResult_RoomInfo* internal_default_instance() {
    return reinterpret_cast<const SCRoomsResult_RoomInfo*>(
               &_SCRoomsResult_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SCRoomsResult_RoomInfo& a, SCRoomsResult_RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SCRoomsResult_RoomInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCRoomsResult_RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCRoomsResult_RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCRoomsResult_RoomInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCRoomsResult_RoomInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCRoomsResult_RoomInfo& from) {
    SCRoomsResult_RoomInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCRoomsResult_RoomInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCRoomsResult.RoomInfo";
  }
  protected:
  explicit SCRoomsResult_RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 3,
    kTitleFieldNumber = 2,
    kRoomIdFieldNumber = 1,
  };
  // repeated string members = 3;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  const std::string& members(int index) const;
  std::string* mutable_members(int index);
  void set_members(int index, const std::string& value);
  void set_members(int index, std::string&& value);
  void set_members(int index, const char* value);
  void set_members(int index, const char* value, size_t size);
  std::string* add_members();
  void add_members(const std::string& value);
  void add_members(std::string&& value);
  void add_members(const char* value);
  void add_members(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_members();
  private:
  const std::string& _internal_members(int index) const;
  std::string* _internal_add_members();
  public:

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // required int32 roomId = 1;
  bool has_roomid() const;
  private:
  bool _internal_has_roomid() const;
  public:
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mju.SCRoomsResult.RoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> members_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    int32_t roomid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCRoomsResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCRoomsResult) */ {
 public:
  inline SCRoomsResult() : SCRoomsResult(nullptr) {}
  ~SCRoomsResult() override;
  explicit PROTOBUF_CONSTEXPR SCRoomsResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCRoomsResult(const SCRoomsResult& from);
  SCRoomsResult(SCRoomsResult&& from) noexcept
    : SCRoomsResult() {
    *this = ::std::move(from);
  }

  inline SCRoomsResult& operator=(const SCRoomsResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCRoomsResult& operator=(SCRoomsResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCRoomsResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCRoomsResult* internal_default_instance() {
    return reinterpret_cast<const SCRoomsResult*>(
               &_SCRoomsResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SCRoomsResult& a, SCRoomsResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SCRoomsResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCRoomsResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCRoomsResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCRoomsResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCRoomsResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCRoomsResult& from) {
    SCRoomsResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCRoomsResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCRoomsResult";
  }
  protected:
  explicit SCRoomsResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SCRoomsResult_RoomInfo RoomInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .mju.SCRoomsResult.RoomInfo rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::mju::SCRoomsResult_RoomInfo* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mju::SCRoomsResult_RoomInfo >*
      mutable_rooms();
  private:
  const ::mju::SCRoomsResult_RoomInfo& _internal_rooms(int index) const;
  ::mju::SCRoomsResult_RoomInfo* _internal_add_rooms();
  public:
  const ::mju::SCRoomsResult_RoomInfo& rooms(int index) const;
  ::mju::SCRoomsResult_RoomInfo* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mju::SCRoomsResult_RoomInfo >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:mju.SCRoomsResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mju::SCRoomsResult_RoomInfo > rooms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCCreateRoomResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCCreateRoomResult) */ {
 public:
  inline SCCreateRoomResult() : SCCreateRoomResult(nullptr) {}
  ~SCCreateRoomResult() override;
  explicit PROTOBUF_CONSTEXPR SCCreateRoomResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCCreateRoomResult(const SCCreateRoomResult& from);
  SCCreateRoomResult(SCCreateRoomResult&& from) noexcept
    : SCCreateRoomResult() {
    *this = ::std::move(from);
  }

  inline SCCreateRoomResult& operator=(const SCCreateRoomResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCCreateRoomResult& operator=(SCCreateRoomResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCCreateRoomResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCCreateRoomResult* internal_default_instance() {
    return reinterpret_cast<const SCCreateRoomResult*>(
               &_SCCreateRoomResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SCCreateRoomResult& a, SCCreateRoomResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SCCreateRoomResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCCreateRoomResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCCreateRoomResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCCreateRoomResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCCreateRoomResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCCreateRoomResult& from) {
    SCCreateRoomResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCCreateRoomResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCCreateRoomResult";
  }
  protected:
  explicit SCCreateRoomResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:mju.SCCreateRoomResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCJoinRoomResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCJoinRoomResult) */ {
 public:
  inline SCJoinRoomResult() : SCJoinRoomResult(nullptr) {}
  ~SCJoinRoomResult() override;
  explicit PROTOBUF_CONSTEXPR SCJoinRoomResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCJoinRoomResult(const SCJoinRoomResult& from);
  SCJoinRoomResult(SCJoinRoomResult&& from) noexcept
    : SCJoinRoomResult() {
    *this = ::std::move(from);
  }

  inline SCJoinRoomResult& operator=(const SCJoinRoomResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCJoinRoomResult& operator=(SCJoinRoomResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCJoinRoomResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCJoinRoomResult* internal_default_instance() {
    return reinterpret_cast<const SCJoinRoomResult*>(
               &_SCJoinRoomResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SCJoinRoomResult& a, SCJoinRoomResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SCJoinRoomResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCJoinRoomResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCJoinRoomResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCJoinRoomResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCJoinRoomResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCJoinRoomResult& from) {
    SCJoinRoomResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCJoinRoomResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCJoinRoomResult";
  }
  protected:
  explicit SCJoinRoomResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:mju.SCJoinRoomResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCLeaveRoomResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCLeaveRoomResult) */ {
 public:
  inline SCLeaveRoomResult() : SCLeaveRoomResult(nullptr) {}
  ~SCLeaveRoomResult() override;
  explicit PROTOBUF_CONSTEXPR SCLeaveRoomResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCLeaveRoomResult(const SCLeaveRoomResult& from);
  SCLeaveRoomResult(SCLeaveRoomResult&& from) noexcept
    : SCLeaveRoomResult() {
    *this = ::std::move(from);
  }

  inline SCLeaveRoomResult& operator=(const SCLeaveRoomResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCLeaveRoomResult& operator=(SCLeaveRoomResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCLeaveRoomResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCLeaveRoomResult* internal_default_instance() {
    return reinterpret_cast<const SCLeaveRoomResult*>(
               &_SCLeaveRoomResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SCLeaveRoomResult& a, SCLeaveRoomResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SCLeaveRoomResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCLeaveRoomResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCLeaveRoomResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCLeaveRoomResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCLeaveRoomResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCLeaveRoomResult& from) {
    SCLeaveRoomResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCLeaveRoomResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCLeaveRoomResult";
  }
  protected:
  explicit SCLeaveRoomResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:mju.SCLeaveRoomResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCChat) */ {
 public:
  inline SCChat() : SCChat(nullptr) {}
  ~SCChat() override;
  explicit PROTOBUF_CONSTEXPR SCChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCChat(const SCChat& from);
  SCChat(SCChat&& from) noexcept
    : SCChat() {
    *this = ::std::move(from);
  }

  inline SCChat& operator=(const SCChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCChat& operator=(SCChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCChat* internal_default_instance() {
    return reinterpret_cast<const SCChat*>(
               &_SCChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SCChat& a, SCChat& b) {
    a.Swap(&b);
  }
  inline void Swap(SCChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCChat& from) {
    SCChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCChat";
  }
  protected:
  explicit SCChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemberFieldNumber = 1,
    kTextFieldNumber = 2,
  };
  // required string member = 1;
  bool has_member() const;
  private:
  bool _internal_has_member() const;
  public:
  void clear_member();
  const std::string& member() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_member(ArgT0&& arg0, ArgT... args);
  std::string* mutable_member();
  PROTOBUF_NODISCARD std::string* release_member();
  void set_allocated_member(std::string* member);
  private:
  const std::string& _internal_member() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_member(const std::string& value);
  std::string* _internal_mutable_member();
  public:

  // required string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:mju.SCChat)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr member_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCSystemMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCSystemMessage) */ {
 public:
  inline SCSystemMessage() : SCSystemMessage(nullptr) {}
  ~SCSystemMessage() override;
  explicit PROTOBUF_CONSTEXPR SCSystemMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCSystemMessage(const SCSystemMessage& from);
  SCSystemMessage(SCSystemMessage&& from) noexcept
    : SCSystemMessage() {
    *this = ::std::move(from);
  }

  inline SCSystemMessage& operator=(const SCSystemMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCSystemMessage& operator=(SCSystemMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCSystemMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCSystemMessage* internal_default_instance() {
    return reinterpret_cast<const SCSystemMessage*>(
               &_SCSystemMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SCSystemMessage& a, SCSystemMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SCSystemMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCSystemMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCSystemMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCSystemMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCSystemMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCSystemMessage& from) {
    SCSystemMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCSystemMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCSystemMessage";
  }
  protected:
  explicit SCSystemMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // required string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:mju.SCSystemMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Type

// required .mju.Type.MessageType type = 1;
inline bool Type::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Type::has_type() const {
  return _internal_has_type();
}
inline void Type::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::mju::Type_MessageType Type::_internal_type() const {
  return static_cast< ::mju::Type_MessageType >(_impl_.type_);
}
inline ::mju::Type_MessageType Type::type() const {
  // @@protoc_insertion_point(field_get:mju.Type.type)
  return _internal_type();
}
inline void Type::_internal_set_type(::mju::Type_MessageType value) {
  assert(::mju::Type_MessageType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void Type::set_type(::mju::Type_MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mju.Type.type)
}

// -------------------------------------------------------------------

// CSName

// required string name = 1;
inline bool CSName::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSName::has_name() const {
  return _internal_has_name();
}
inline void CSName::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSName::name() const {
  // @@protoc_insertion_point(field_get:mju.CSName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSName::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mju.CSName.name)
}
inline std::string* CSName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mju.CSName.name)
  return _s;
}
inline const std::string& CSName::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CSName::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CSName::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CSName::release_name() {
  // @@protoc_insertion_point(field_release:mju.CSName.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mju.CSName.name)
}

// -------------------------------------------------------------------

// CSRooms

// -------------------------------------------------------------------

// CSCreateRoom

// optional string title = 1;
inline bool CSCreateRoom::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSCreateRoom::has_title() const {
  return _internal_has_title();
}
inline void CSCreateRoom::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSCreateRoom::title() const {
  // @@protoc_insertion_point(field_get:mju.CSCreateRoom.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSCreateRoom::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mju.CSCreateRoom.title)
}
inline std::string* CSCreateRoom::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:mju.CSCreateRoom.title)
  return _s;
}
inline const std::string& CSCreateRoom::_internal_title() const {
  return _impl_.title_.Get();
}
inline void CSCreateRoom::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* CSCreateRoom::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* CSCreateRoom::release_title() {
  // @@protoc_insertion_point(field_release:mju.CSCreateRoom.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSCreateRoom::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mju.CSCreateRoom.title)
}

// -------------------------------------------------------------------

// CSJoinRoom

// required int32 roomId = 1;
inline bool CSJoinRoom::_internal_has_roomid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSJoinRoom::has_roomid() const {
  return _internal_has_roomid();
}
inline void CSJoinRoom::clear_roomid() {
  _impl_.roomid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CSJoinRoom::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t CSJoinRoom::roomid() const {
  // @@protoc_insertion_point(field_get:mju.CSJoinRoom.roomId)
  return _internal_roomid();
}
inline void CSJoinRoom::_internal_set_roomid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.roomid_ = value;
}
inline void CSJoinRoom::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:mju.CSJoinRoom.roomId)
}

// -------------------------------------------------------------------

// CSLeaveRoom

// -------------------------------------------------------------------

// CSChat

// required string text = 1;
inline bool CSChat::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSChat::has_text() const {
  return _internal_has_text();
}
inline void CSChat::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSChat::text() const {
  // @@protoc_insertion_point(field_get:mju.CSChat.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSChat::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mju.CSChat.text)
}
inline std::string* CSChat::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:mju.CSChat.text)
  return _s;
}
inline const std::string& CSChat::_internal_text() const {
  return _impl_.text_.Get();
}
inline void CSChat::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* CSChat::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* CSChat::release_text() {
  // @@protoc_insertion_point(field_release:mju.CSChat.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSChat::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mju.CSChat.text)
}

// -------------------------------------------------------------------

// CSShutdown

// -------------------------------------------------------------------

// SCNameResult

// optional string error = 1;
inline bool SCNameResult::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCNameResult::has_error() const {
  return _internal_has_error();
}
inline void SCNameResult::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCNameResult::error() const {
  // @@protoc_insertion_point(field_get:mju.SCNameResult.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCNameResult::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mju.SCNameResult.error)
}
inline std::string* SCNameResult::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:mju.SCNameResult.error)
  return _s;
}
inline const std::string& SCNameResult::_internal_error() const {
  return _impl_.error_.Get();
}
inline void SCNameResult::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* SCNameResult::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* SCNameResult::release_error() {
  // @@protoc_insertion_point(field_release:mju.SCNameResult.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SCNameResult::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mju.SCNameResult.error)
}

// -------------------------------------------------------------------

// SCRoomsResult_RoomInfo

// required int32 roomId = 1;
inline bool SCRoomsResult_RoomInfo::_internal_has_roomid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SCRoomsResult_RoomInfo::has_roomid() const {
  return _internal_has_roomid();
}
inline void SCRoomsResult_RoomInfo::clear_roomid() {
  _impl_.roomid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SCRoomsResult_RoomInfo::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t SCRoomsResult_RoomInfo::roomid() const {
  // @@protoc_insertion_point(field_get:mju.SCRoomsResult.RoomInfo.roomId)
  return _internal_roomid();
}
inline void SCRoomsResult_RoomInfo::_internal_set_roomid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.roomid_ = value;
}
inline void SCRoomsResult_RoomInfo::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:mju.SCRoomsResult.RoomInfo.roomId)
}

// optional string title = 2;
inline bool SCRoomsResult_RoomInfo::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCRoomsResult_RoomInfo::has_title() const {
  return _internal_has_title();
}
inline void SCRoomsResult_RoomInfo::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCRoomsResult_RoomInfo::title() const {
  // @@protoc_insertion_point(field_get:mju.SCRoomsResult.RoomInfo.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCRoomsResult_RoomInfo::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mju.SCRoomsResult.RoomInfo.title)
}
inline std::string* SCRoomsResult_RoomInfo::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:mju.SCRoomsResult.RoomInfo.title)
  return _s;
}
inline const std::string& SCRoomsResult_RoomInfo::_internal_title() const {
  return _impl_.title_.Get();
}
inline void SCRoomsResult_RoomInfo::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* SCRoomsResult_RoomInfo::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* SCRoomsResult_RoomInfo::release_title() {
  // @@protoc_insertion_point(field_release:mju.SCRoomsResult.RoomInfo.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SCRoomsResult_RoomInfo::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mju.SCRoomsResult.RoomInfo.title)
}

// repeated string members = 3;
inline int SCRoomsResult_RoomInfo::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int SCRoomsResult_RoomInfo::members_size() const {
  return _internal_members_size();
}
inline void SCRoomsResult_RoomInfo::clear_members() {
  _impl_.members_.Clear();
}
inline std::string* SCRoomsResult_RoomInfo::add_members() {
  std::string* _s = _internal_add_members();
  // @@protoc_insertion_point(field_add_mutable:mju.SCRoomsResult.RoomInfo.members)
  return _s;
}
inline const std::string& SCRoomsResult_RoomInfo::_internal_members(int index) const {
  return _impl_.members_.Get(index);
}
inline const std::string& SCRoomsResult_RoomInfo::members(int index) const {
  // @@protoc_insertion_point(field_get:mju.SCRoomsResult.RoomInfo.members)
  return _internal_members(index);
}
inline std::string* SCRoomsResult_RoomInfo::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:mju.SCRoomsResult.RoomInfo.members)
  return _impl_.members_.Mutable(index);
}
inline void SCRoomsResult_RoomInfo::set_members(int index, const std::string& value) {
  _impl_.members_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mju.SCRoomsResult.RoomInfo.members)
}
inline void SCRoomsResult_RoomInfo::set_members(int index, std::string&& value) {
  _impl_.members_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mju.SCRoomsResult.RoomInfo.members)
}
inline void SCRoomsResult_RoomInfo::set_members(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.members_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mju.SCRoomsResult.RoomInfo.members)
}
inline void SCRoomsResult_RoomInfo::set_members(int index, const char* value, size_t size) {
  _impl_.members_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mju.SCRoomsResult.RoomInfo.members)
}
inline std::string* SCRoomsResult_RoomInfo::_internal_add_members() {
  return _impl_.members_.Add();
}
inline void SCRoomsResult_RoomInfo::add_members(const std::string& value) {
  _impl_.members_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mju.SCRoomsResult.RoomInfo.members)
}
inline void SCRoomsResult_RoomInfo::add_members(std::string&& value) {
  _impl_.members_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mju.SCRoomsResult.RoomInfo.members)
}
inline void SCRoomsResult_RoomInfo::add_members(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.members_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mju.SCRoomsResult.RoomInfo.members)
}
inline void SCRoomsResult_RoomInfo::add_members(const char* value, size_t size) {
  _impl_.members_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mju.SCRoomsResult.RoomInfo.members)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SCRoomsResult_RoomInfo::members() const {
  // @@protoc_insertion_point(field_list:mju.SCRoomsResult.RoomInfo.members)
  return _impl_.members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SCRoomsResult_RoomInfo::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:mju.SCRoomsResult.RoomInfo.members)
  return &_impl_.members_;
}

// -------------------------------------------------------------------

// SCRoomsResult

// repeated .mju.SCRoomsResult.RoomInfo rooms = 1;
inline int SCRoomsResult::_internal_rooms_size() const {
  return _impl_.rooms_.size();
}
inline int SCRoomsResult::rooms_size() const {
  return _internal_rooms_size();
}
inline void SCRoomsResult::clear_rooms() {
  _impl_.rooms_.Clear();
}
inline ::mju::SCRoomsResult_RoomInfo* SCRoomsResult::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:mju.SCRoomsResult.rooms)
  return _impl_.rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mju::SCRoomsResult_RoomInfo >*
SCRoomsResult::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:mju.SCRoomsResult.rooms)
  return &_impl_.rooms_;
}
inline const ::mju::SCRoomsResult_RoomInfo& SCRoomsResult::_internal_rooms(int index) const {
  return _impl_.rooms_.Get(index);
}
inline const ::mju::SCRoomsResult_RoomInfo& SCRoomsResult::rooms(int index) const {
  // @@protoc_insertion_point(field_get:mju.SCRoomsResult.rooms)
  return _internal_rooms(index);
}
inline ::mju::SCRoomsResult_RoomInfo* SCRoomsResult::_internal_add_rooms() {
  return _impl_.rooms_.Add();
}
inline ::mju::SCRoomsResult_RoomInfo* SCRoomsResult::add_rooms() {
  ::mju::SCRoomsResult_RoomInfo* _add = _internal_add_rooms();
  // @@protoc_insertion_point(field_add:mju.SCRoomsResult.rooms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mju::SCRoomsResult_RoomInfo >&
SCRoomsResult::rooms() const {
  // @@protoc_insertion_point(field_list:mju.SCRoomsResult.rooms)
  return _impl_.rooms_;
}

// -------------------------------------------------------------------

// SCCreateRoomResult

// optional string error = 1;
inline bool SCCreateRoomResult::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCCreateRoomResult::has_error() const {
  return _internal_has_error();
}
inline void SCCreateRoomResult::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCCreateRoomResult::error() const {
  // @@protoc_insertion_point(field_get:mju.SCCreateRoomResult.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCCreateRoomResult::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mju.SCCreateRoomResult.error)
}
inline std::string* SCCreateRoomResult::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:mju.SCCreateRoomResult.error)
  return _s;
}
inline const std::string& SCCreateRoomResult::_internal_error() const {
  return _impl_.error_.Get();
}
inline void SCCreateRoomResult::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* SCCreateRoomResult::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* SCCreateRoomResult::release_error() {
  // @@protoc_insertion_point(field_release:mju.SCCreateRoomResult.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SCCreateRoomResult::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mju.SCCreateRoomResult.error)
}

// -------------------------------------------------------------------

// SCJoinRoomResult

// optional string error = 1;
inline bool SCJoinRoomResult::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCJoinRoomResult::has_error() const {
  return _internal_has_error();
}
inline void SCJoinRoomResult::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCJoinRoomResult::error() const {
  // @@protoc_insertion_point(field_get:mju.SCJoinRoomResult.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCJoinRoomResult::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mju.SCJoinRoomResult.error)
}
inline std::string* SCJoinRoomResult::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:mju.SCJoinRoomResult.error)
  return _s;
}
inline const std::string& SCJoinRoomResult::_internal_error() const {
  return _impl_.error_.Get();
}
inline void SCJoinRoomResult::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* SCJoinRoomResult::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* SCJoinRoomResult::release_error() {
  // @@protoc_insertion_point(field_release:mju.SCJoinRoomResult.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SCJoinRoomResult::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mju.SCJoinRoomResult.error)
}

// -------------------------------------------------------------------

// SCLeaveRoomResult

// optional string error = 1;
inline bool SCLeaveRoomResult::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCLeaveRoomResult::has_error() const {
  return _internal_has_error();
}
inline void SCLeaveRoomResult::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCLeaveRoomResult::error() const {
  // @@protoc_insertion_point(field_get:mju.SCLeaveRoomResult.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCLeaveRoomResult::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mju.SCLeaveRoomResult.error)
}
inline std::string* SCLeaveRoomResult::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:mju.SCLeaveRoomResult.error)
  return _s;
}
inline const std::string& SCLeaveRoomResult::_internal_error() const {
  return _impl_.error_.Get();
}
inline void SCLeaveRoomResult::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* SCLeaveRoomResult::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* SCLeaveRoomResult::release_error() {
  // @@protoc_insertion_point(field_release:mju.SCLeaveRoomResult.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SCLeaveRoomResult::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mju.SCLeaveRoomResult.error)
}

// -------------------------------------------------------------------

// SCChat

// required string member = 1;
inline bool SCChat::_internal_has_member() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCChat::has_member() const {
  return _internal_has_member();
}
inline void SCChat::clear_member() {
  _impl_.member_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCChat::member() const {
  // @@protoc_insertion_point(field_get:mju.SCChat.member)
  return _internal_member();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCChat::set_member(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.member_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mju.SCChat.member)
}
inline std::string* SCChat::mutable_member() {
  std::string* _s = _internal_mutable_member();
  // @@protoc_insertion_point(field_mutable:mju.SCChat.member)
  return _s;
}
inline const std::string& SCChat::_internal_member() const {
  return _impl_.member_.Get();
}
inline void SCChat::_internal_set_member(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.member_.Set(value, GetArenaForAllocation());
}
inline std::string* SCChat::_internal_mutable_member() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.member_.Mutable(GetArenaForAllocation());
}
inline std::string* SCChat::release_member() {
  // @@protoc_insertion_point(field_release:mju.SCChat.member)
  if (!_internal_has_member()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.member_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.member_.IsDefault()) {
    _impl_.member_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SCChat::set_allocated_member(std::string* member) {
  if (member != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.member_.SetAllocated(member, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.member_.IsDefault()) {
    _impl_.member_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mju.SCChat.member)
}

// required string text = 2;
inline bool SCChat::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SCChat::has_text() const {
  return _internal_has_text();
}
inline void SCChat::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SCChat::text() const {
  // @@protoc_insertion_point(field_get:mju.SCChat.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCChat::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mju.SCChat.text)
}
inline std::string* SCChat::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:mju.SCChat.text)
  return _s;
}
inline const std::string& SCChat::_internal_text() const {
  return _impl_.text_.Get();
}
inline void SCChat::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* SCChat::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* SCChat::release_text() {
  // @@protoc_insertion_point(field_release:mju.SCChat.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SCChat::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mju.SCChat.text)
}

// -------------------------------------------------------------------

// SCSystemMessage

// required string text = 1;
inline bool SCSystemMessage::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCSystemMessage::has_text() const {
  return _internal_has_text();
}
inline void SCSystemMessage::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCSystemMessage::text() const {
  // @@protoc_insertion_point(field_get:mju.SCSystemMessage.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCSystemMessage::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mju.SCSystemMessage.text)
}
inline std::string* SCSystemMessage::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:mju.SCSystemMessage.text)
  return _s;
}
inline const std::string& SCSystemMessage::_internal_text() const {
  return _impl_.text_.Get();
}
inline void SCSystemMessage::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* SCSystemMessage::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* SCSystemMessage::release_text() {
  // @@protoc_insertion_point(field_release:mju.SCSystemMessage.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SCSystemMessage::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mju.SCSystemMessage.text)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mju

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mju::Type_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mju::Type_MessageType>() {
  return ::mju::Type_MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
